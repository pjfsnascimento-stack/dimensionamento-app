# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KQ-l4XxPJeJSv0s2GOnudn-u20Nha9lu
"""

# ==============================================================================
# MÓDULO 1: CONFIGURAÇÃO E CARREGAMENTO DE DADOS (VERSÃO FINAL)
# ==============================================================================
print("Iniciando Módulo 1...")
# Instalação da biblioteca
import pandas as pd
from pyworkforce.queuing import ErlangC
print("Bibliotecas importadas.")

# Carregamento robusto dos dados (tenta com ';' e depois com ',')
try:
    df = pd.read_csv('chamadas.csv', sep=';')
    print("Arquivo 'chamadas.csv' carregado com sucesso usando separador ';'.")
except (ParserError, UnicodeDecodeError, ValueError):
    try:
        df = pd.read_csv('chamadas.csv', sep=',')
        print("Arquivo 'chamadas.csv' carregado com sucesso usando separador ','.")
    except Exception as e:
        print(f"ERRO CRÍTICO: Não foi possível ler o arquivo CSV. Verifique o formato e o separador. Detalhes: {e}")
except FileNotFoundError:
    print("ERRO CRÍTICO: Arquivo 'chamadas.csv' não encontrado. Por favor, faça o upload.")

print("Módulo 1 concluído.")

# ==============================================================================
# MÓDULO 2: TRATAMENTO E ANÁLISE DOS DADOS (VERSÃO FINAL)
# ==============================================================================
print("\nIniciando Módulo 2...")
# Conversão segura da coluna de data
df['data_hora_inicio'] = pd.to_datetime(df['data_hora_inicio'], errors='coerce')
linhas_com_erro_data = df['data_hora_inicio'].isnull().sum()
if linhas_com_erro_data > 0:
    print(f"ATENÇÃO: {linhas_com_erro_data} linha(s) com data inválida foram removidas.")
    df.dropna(subset=['data_hora_inicio'], inplace=True)

# Conversão segura da coluna de duração
df['duracao_atendimento'] = pd.to_numeric(df['duracao_atendimento'], errors='coerce')
linhas_com_erro_duracao = df['duracao_atendimento'].isnull().sum()
if linhas_com_erro_duracao > 0:
    print(f"ATENÇÃO: {linhas_com_erro_duracao} linha(s) com 'duracao_atendimento' inválida foram removidas.")
    df.dropna(subset=['duracao_atendimento'], inplace=True)
print("Limpeza de dados concluída.")

# Criação das colunas de agrupamento
df['dia_da_semana_num'] = df['data_hora_inicio'].dt.dayofweek
df['hora'] = df['data_hora_inicio'].dt.hour
dias_map = {0: '1-Segunda', 1: '2-Terça', 2: '3-Quarta', 3: '4-Quinta', 4: '5-Sexta', 5: '6-Sábado', 6: '7-Domingo'}
df['dia_da_semana'] = df['dia_da_semana_num'].map(dias_map)

# Cálculo da média de chamadas
dias_no_historico = (df['data_hora_inicio'].max() - df['data_hora_inicio'].min()).days
num_semanas = dias_no_historico / 7 if dias_no_historico > 0 else 1
if num_semanas < 1: num_semanas = 1

analise_horaria = df.groupby(['dia_da_semana', 'hora']).agg(
    tma_medio=('duracao_atendimento', 'mean'),
    total_chamadas=('data_hora_inicio', 'count')
).reset_index()
analise_horaria['chamadas_por_hora'] = analise_horaria['total_chamadas'] / num_semanas
print("Análise horária concluída.")
print("Módulo 2 concluído.")

# ==============================================================================
# MÓDULO 3: MOTOR DE DIMENSIONAMENTO (VERSÃO FINAL)
# ==============================================================================
print("\nIniciando Módulo 3...")
META_SL = 0.90
META_TEMPO_ATENDIMENTO = 15
escala_recomendada = []

for index, row in analise_horaria.iterrows():
    chamadas_hora = row['chamadas_por_hora']
    tma = row['tma_medio']
    if chamadas_hora > 0:
        for n_atendentes in range(1, 100):
            erlang = ErlangC(transactions=chamadas_hora, aht=tma, interval=3600, asa=META_TEMPO_ATENDIMENTO)
            sl_previsto = erlang.service_level(positions=n_atendentes)
            if sl_previsto >= META_SL:
                atendentes_necessarios = n_atendentes
                # CORREÇÃO APLICADA: Nome da função de ocupação
                ocupacao_prevista = erlang.achieved_occupancy(positions=n_atendentes)
                break
        else:
            atendentes_necessarios, ocupacao_prevista = 99, 1.0
    else:
        atendentes_necessarios, sl_previsto, ocupacao_prevista = 0, 1.0, 0.0

    escala_recomendada.append({
        'dia_da_semana': row['dia_da_semana'], 'hora': row['hora'],
        'atendentes_necessarios': atendentes_necessarios, 'sl_previsto_com_escala': round(sl_previsto, 3),
        'ocupacao_prevista': round(ocupacao_prevista, 3), 'chamadas_esperadas': round(chamadas_hora, 1),
        'tma_medio_esperado': round(tma, 1)
    })

df_escala = pd.DataFrame(escala_recomendada)
print("Dimensionamento concluído.")
print("Módulo 3 concluído.")

# ==============================================================================
# MÓDULO 4: FERRAMENTA DE SIMULAÇÃO (VERSÃO FINAL)
# ==============================================================================
print("\nIniciando Módulo 4...")

def simular_cenario(chamadas_por_hora, tma_segundos, n_atendentes, meta_sl=0.90, meta_tempo_atendimento=15):
    if chamadas_por_hora <= 0:
        print("Volume de chamadas deve ser maior que zero para simular.")
        return

    erlang = ErlangC(transactions=chamadas_por_hora, aht=tma_segundos, interval=3600, asa=meta_tempo_atendimento)

    sl_previsto = erlang.service_level(positions=n_atendentes)
    # CORREÇÃO 1 APLICADA: Nome da função de ocupação
    ocupacao = erlang.achieved_occupancy(positions=n_atendentes)
    # CORREÇÃO 2 APLICADA: Nome da função de tempo de espera
    espera_media = erlang.average_waiting_time(positions=n_atendentes)

    print("\n" + "---" * 15)
    print("        RESULTADO DA SIMULAÇÃO DE CENÁRIO")
    print("---" * 15)
    print(f" PARÂMETROS DE ENTRADA:")
    print(f"   - Volume de chamadas: {chamadas_por_hora:.1f}/hora")
    print(f"   - TMA: {tma_segundos:.1f} segundos")
    print(f"   - Atendentes: {n_atendentes}")
    print("\n PREVISÕES DO MODELO:")
    print(f"   - Nível de Serviço Previsto: {sl_previsto:.2%}")
    print(f"   - Tempo Médio de Espera na Fila: {espera_media:.2f} segundos")
    print(f"   - Ocupação Média dos Atendentes: {ocupacao:.2%}")
    print("---" * 15)
    if sl_previsto >= meta_sl: print(" CONCLUSÃO: META ATINGIDA.")
    else: print(" CONCLUSÃO: ALERTA! META NÃO ATINGIDA.")
    print("---" * 15)

# --- Exemplo de uso ---
print("Executando simulação de exemplo:")
simular_cenario(chamadas_por_hora=50, tma_segundos=180, n_atendentes=4)
print("\nMódulo 4 concluído.")

# ==============================================================================
# MÓDULO 5: VISUALIZAÇÃO E EXPORTAÇÃO (VERSÃO FINAL)
# ==============================================================================
print("\nIniciando Módulo 5...")
import matplotlib.pyplot as plt
import seaborn as sns

# Tabela pivô para visualização em grade
escala_pivot = df_escala.pivot_table(index='hora', columns='dia_da_semana', values='atendentes_necessarios')
colunas_ordenadas = [col for col in ['1-Segunda', '2-Terça', '3-Quarta', '4-Quinta', '5-Sexta', '6-Sábado', '7-Domingo'] if col in escala_pivot.columns]
escala_pivot = escala_pivot[colunas_ordenadas]

print("\n--- ESCALA SEMANAL RECOMENDADA (GRADE) ---")
print(escala_pivot.fillna(0).astype(int))

# Mapa de calor
plt.figure(figsize=(18, 10))
sns.heatmap(escala_pivot.fillna(0).astype(int), annot=True, fmt='d', cmap='YlGnBu', linewidths=.5)
plt.title('Mapa de Calor da Escala de Atendentes Necessários', fontsize=16)
plt.xlabel('Dia da Semana', fontsize=12)
plt.ylabel('Hora do Dia', fontsize=12)
plt.show()

# Exportação para CSV
nome_arquivo_saida = 'escala_recomendada.csv'
df_escala.sort_values(by=['dia_da_semana', 'hora']).to_csv(nome_arquivo_saida, index=False, sep=';', decimal=',')
print(f"\nEscala completa salva com sucesso no arquivo '{nome_arquivo_saida}'.")
print("Você pode baixá-lo no menu 'Arquivos' (ícone de pasta) à esquerda.")
print("\nMódulo 5 concluído. PROCESSO FINALIZADO COM SUCESSO!")

# CÓDIGO DE DIAGNÓSTICO - VERSÃO CORRIGIDA
!pip install pyworkforce -q
from pyworkforce.queuing import ErlangC

# CORREÇÃO: Adicionamos o argumento obrigatório 'asa'
erlang_teste = ErlangC(transactions=10, aht=10, interval=3600, asa=15)

print("--- Funções disponíveis na biblioteca ErlangC ---")
for item in dir(erlang_teste):
  if not item.startswith('_'):
    print(item)
print("-------------------------------------------------")

# ==============================================================================
# SISTEMA DE DIMENSIONAMENTO DE EQUIPE - VERSÃO 3.0 (COMPATÍVEL)
# ==============================================================================
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import math
import sys

try:
    # --- MÓDULO 1: CONFIGURAÇÃO E CARREGAMENTO ---
    print("MÓDULO 1: Iniciando configuração e carregamento...")
    !pip install pyworkforce -q
    from pyworkforce.queuing import ErlangC

    try:
        df = pd.read_csv('chamadas.csv', sep=';')
    except (ValueError, ParserError):
        df = pd.read_csv('chamadas.csv', sep=',')
    print("-> Arquivo 'chamadas.csv' carregado com sucesso.")

    # --- MÓDULO 2: TRATAMENTO E ANÁLISE DOS DADOS ---
    print("\nMÓDULO 2: Iniciando limpeza e análise dos dados...")
    df['data_hora_inicio'] = pd.to_datetime(df['data_hora_inicio'], errors='coerce')
    df['duracao_atendimento'] = pd.to_numeric(df['duracao_atendimento'], errors='coerce')
    df.dropna(subset=['data_hora_inicio', 'duracao_atendimento'], inplace=True)
    print("-> Dados limpos e convertidos.")

    df['dia_da_semana_num'] = df['data_hora_inicio'].dt.dayofweek
    df['hora'] = df['data_hora_inicio'].dt.hour
    dias_map = {0: '1-Segunda', 1: '2-Terça', 2: '3-Quarta', 3: '4-Quinta', 4: '5-Sexta', 5: '6-Sábado', 6: '7-Domingo'}
    df['dia_da_semana'] = df['dia_da_semana_num'].map(dias_map)

    dias_no_historico = (df['data_hora_inicio'].max() - df['data_hora_inicio'].min()).days
    num_semanas = dias_no_historico / 7 if dias_no_historico > 0 else 1
    if num_semanas < 1: num_semanas = 1

    analise_horaria = df.groupby(['dia_da_semana', 'hora']).agg(
        tma_medio=('duracao_atendimento', 'mean'),
        total_chamadas=('data_hora_inicio', 'count')
    ).reset_index()
    analise_horaria['chamadas_por_hora'] = analise_horaria['total_chamadas'] / num_semanas
    print("-> Análise de volume e TMA por hora concluída.")

    # --- MÓDULO 3: MOTOR DE DIMENSIONAMENTO ---
    print("\nMÓDULO 3: Iniciando dimensionamento da equipe...")
    META_SL = 0.90
    META_TEMPO_ATENDIMENTO = 15
    escala_recomendada = []

    for index, row in analise_horaria.iterrows():
        chamadas_hora = row['chamadas_por_hora']
        tma = row['tma_medio']
        if chamadas_hora > 0 and tma > 0:
            for n_atendentes in range(1, 100):
                erlang = ErlangC(transactions=chamadas_hora, aht=tma, interval=3600, asa=META_TEMPO_ATENDIMENTO)
                sl_previsto = erlang.service_level(positions=n_atendentes)
                if sl_previsto >= META_SL:
                    atendentes_necessarios = n_atendentes
                    ocupacao_prevista = erlang.achieved_occupancy(positions=n_atendentes)
                    break
            else:
                atendentes_necessarios, ocupacao_prevista = 99, 1.0
        else:
            atendentes_necessarios, sl_previsto, ocupacao_prevista = 0, 1.0, 0.0
        escala_recomendada.append({
            'dia_da_semana': row['dia_da_semana'], 'hora': row['hora'],
            'atendentes_necessarios': atendentes_necessarios, 'sl_previsto_com_escala': round(sl_previsto, 3),
            'ocupacao_prevista': round(ocupacao_prevista, 3)
        })
    df_escala = pd.DataFrame(escala_recomendada)
    print("-> Dimensionamento da escala finalizado.")

    if df_escala.empty:
        raise ValueError("ERRO CRÍTICO: A escala recomendada (df_escala) não pôde ser gerada.")

    # --- MÓDULO 4: FERRAMENTA DE SIMULAÇÃO ---
    print("\nMÓDULO 4: Configurando a ferramenta de simulação...")
    def simular_cenario(chamadas_por_hora, tma_segundos, n_atendentes):
        erlang = ErlangC(transactions=chamadas_por_hora, aht=tma_segundos, interval=3600, asa=META_TEMPO_ATENDIMENTO)
        sl = erlang.service_level(positions=n_atendentes)
        ocupacao = erlang.achieved_occupancy(positions=n_atendentes)
        # A linha do tempo de espera (que causava o erro) foi removida.
        print(f"\n--- SIMULAÇÃO: {chamadas_por_hora:.1f} chamadas/h, TMA {tma_segundos:.1f}s, {n_atendentes} atendentes ---")
        print(f"   - Nível de Serviço Previsto: {sl:.2%}")
        print(f"   - Ocupação Média: {ocupacao:.2%}")
        if sl >= META_SL: print("   - CONCLUSÃO: META ATINGIDA.")
        else: print("   - CONCLUSÃO: META NÃO ATINGIDA.")

    print("-> Ferramenta de simulação pronta. Executando exemplo:")
    simular_cenario(chamadas_por_hora=50, tma_segundos=180, n_atendentes=4)

    # --- MÓDULO 5: VISUALIZAÇÃO E EXPORTAÇÃO ---
    print("\nMÓDULO 5: Gerando visualizações e arquivo final...")
    escala_pivot = df_escala.pivot_table(index='hora', columns='dia_da_semana', values='atendentes_necessarios')
    colunas = [col for col in ['1-Segunda','2-Terça','3-Quarta','4-Quinta','5-Sexta','6-Sábado','7-Domingo'] if col in escala_pivot.columns]
    escala_pivot = escala_pivot[colunas]
    print("\n--- ESCALA SEMANAL RECOMENDADA (GRADE) ---")
    print(escala_pivot.fillna(0).astype(int))

    plt.figure(figsize=(18, 10))
    sns.heatmap(escala_pivot.fillna(0).astype(int), annot=True, fmt='d', cmap='YlGnBu', linewidths=.5)
    plt.title('Mapa de Calor da Escala de Atendentes Necessários', fontsize=16)
    plt.show()

    nome_arquivo_saida = 'escala_recomendada.csv'
    df_escala.sort_values(by=['dia_da_semana', 'hora']).to_csv(nome_arquivo_saida, index=False, sep=';')
    print(f"\n-> Arquivo '{nome_arquivo_saida}' salvo com sucesso! Você pode encontrá-lo no menu à esquerda.")

    print("\n\n================================================")
    print("==   PROCESSO FINALIZADO COM SUCESSO!   ==")
    print("================================================")

except Exception as e:
    print("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print(f" OCORREU UM ERRO INESPERADO: {e}")
    print(" O processo foi interrompido. Verifique a mensagem de erro acima.")
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    import traceback
    traceback.print_exc()

# ==============================================================================
# SISTEMA DE DIMENSIONAMENTO - VERSÃO FINAL COM DEPURAÇÃO
# ==============================================================================
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import math
import sys

try:
    # --- MÓDULO 1: CONFIGURAÇÃO E CARREGAMENTO ---
    print("MÓDULO 1: Iniciando configuração e carregamento...")
    !pip install pyworkforce -q
    from pyworkforce.queuing import ErlangC

    try:
        df = pd.read_csv('chamadas.csv', sep=';')
    except (ValueError, ParserError):
        df = pd.read_csv('chamadas.csv', sep=',')
    print(f"-> Arquivo 'chamadas.csv' carregado. Shape inicial: {df.shape[0]} linhas, {df.shape[1]} colunas.")

    # --- MÓDULO 2: TRATAMENTO E ANÁLISE DOS DADOS ---
    print("\nMÓDULO 2: Iniciando limpeza e análise dos dados...")

    # Tentativa de conversão de data com formato específico primeiro
    try:
        df['data_hora_inicio'] = pd.to_datetime(df['data_hora_inicio'], format='%Y:%m:%d %H:%M:%S', errors='coerce')
    except (TypeError, ValueError):
        # Fallback para o conversor genérico
        df['data_hora_inicio'] = pd.to_datetime(df['data_hora_inicio'], errors='coerce')

    df['duracao_atendimento'] = pd.to_numeric(df['duracao_atendimento'], errors='coerce')

    linhas_antes = df.shape[0]
    df.dropna(subset=['data_hora_inicio', 'duracao_atendimento'], inplace=True)
    linhas_depois = df.shape[0]
    print(f"-> Limpeza de dados concluída. Linhas removidas por dados inválidos: {linhas_antes - linhas_depois}. Linhas restantes: {linhas_depois}")

    if df.empty:
        raise ValueError("Após a limpeza, nenhuma linha de dados válida restou. Verifique o formato das colunas 'data_hora_inicio' e 'duracao_atendimento' no seu CSV.")

    df['dia_da_semana_num'] = df['data_hora_inicio'].dt.dayofweek
    df['hora'] = df['data_hora_inicio'].dt.hour
    dias_map = {0: '1-Segunda', 1: '2-Terça', 2: '3-Quarta', 3: '4-Quinta', 4: '5-Sexta', 5: '6-Sábado', 6: '7-Domingo'}
    df['dia_da_semana'] = df['dia_da_semana_num'].map(dias_map)

    dias_no_historico = (df['data_hora_inicio'].max() - df['data_hora_inicio'].min()).days
    num_semanas = dias_no_historico / 7 if dias_no_historico > 0 else 1
    if num_semanas < 1: num_semanas = 1

    analise_horaria = df.groupby(['dia_da_semana', 'hora']).agg(
        tma_medio=('duracao_atendimento', 'mean'),
        total_chamadas=('data_hora_inicio', 'count')
    ).reset_index()
    analise_horaria['chamadas_por_hora'] = analise_horaria['total_chamadas'] / num_semanas
    print(f"-> Análise horária concluída. A tabela de análise tem {analise_horaria.shape[0]} linhas.")

    if analise_horaria.empty:
        raise ValueError("A tabela de análise horária foi gerada vazia. Não há dados para dimensionar.")

    # --- MÓDULO 3: MOTOR DE DIMENSIONAMENTO ---
    print("\nMÓDULO 3: Iniciando dimensionamento da equipe...")
    META_SL = 0.90
    META_TEMPO_ATENDIMENTO = 15
    escala_recomendada = []

    for index, row in analise_horaria.iterrows():
        chamadas_hora, tma = row['chamadas_por_hora'], row['tma_medio']
        if chamadas_hora > 0 and tma > 0:
            for n in range(1, 100):
                erlang = ErlangC(transactions=chamadas_hora, aht=tma, interval=3600, asa=META_TEMPO_ATENDIMENTO)
                if erlang.service_level(positions=n) >= META_SL:
                    atendentes_necessarios, ocupacao_prevista = n, erlang.achieved_occupancy(positions=n)
                    break
            else:
                atendentes_necessarios, ocupacao_prevista = 99, 1.0
        else:
            atendentes_necessarios, ocupacao_prevista = 0, 0.0
        escala_recomendada.append({
            'dia_da_semana': row['dia_da_semana'], 'hora': row['hora'],
            'atendentes_necessarios': atendentes_necessarios, 'ocupacao_prevista': round(ocupacao_prevista, 3)
        })
    df_escala = pd.DataFrame(escala_recomendada)
    print(f"-> Dimensionamento da escala finalizado. Tabela de escala gerada com {df_escala.shape[0]} linhas.")

    if df_escala.empty:
        raise ValueError("A escala recomendada (df_escala) não pôde ser gerada. O loop de dimensionamento falhou.")

    # --- MÓDULO 4: FERRAMENTA DE SIMULAÇÃO ---
    print("\nMÓDULO 4: Configurando e testando a ferramenta de simulação...")
    def simular_cenario(chamadas, tma, atendentes):
        erlang = ErlangC(transactions=chamadas, aht=tma, interval=3600, asa=META_TEMPO_ATENDIMENTO)
        sl, ocupacao = erlang.service_level(positions=atendentes), erlang.achieved_occupancy(positions=atendentes)
        print(f"\n--- SIMULAÇÃO: {chamadas:.1f} chamadas/h, TMA {tma:.1f}s, {atendentes} atendentes ---")
        print(f"   - Nível de Serviço Previsto: {sl:.2%}")
        print(f"   - Ocupação Média: {ocupacao:.2%}")
        if sl >= META_SL: print("   - CONCLUSÃO: META ATINGIDA.")
        else: print("   - CONCLUSÃO: META NÃO ATINGIDA.")
    simular_cenario(chamadas=50, tma=180, atendentes=4)

    # --- MÓDULO 5: VISUALIZAÇÃO E EXPORTAÇÃO ---
    print("\nMÓDULO 5: Gerando visualizações e arquivo final...")
    escala_pivot = df_escala.pivot_table(index='hora', columns='dia_da_semana', values='atendentes_necessarios')
    colunas = [col for col in ['1-Segunda','2-Terça','3-Quarta','4-Quinta','5-Sexta','6-Sábado','7-Domingo'] if col in escala_pivot.columns]
    escala_pivot = escala_pivot[colunas]
    print("\n--- ESCALA SEMANAL RECOMENDADA (GRADE) ---")
    print(escala_pivot.fillna(0).astype(int))

    plt.figure(figsize=(18, 10))
    sns.heatmap(escala_pivot.fillna(0).astype(int), annot=True, fmt='d', cmap='YlGnBu', linewidths=.5)
    plt.title('Mapa de Calor da Escala de Atendentes Necessários', fontsize=16)
    plt.show()

    nome_arquivo_saida = 'escala_recomendada.csv'
    df_escala.sort_values(by=['dia_da_semana', 'hora']).to_csv(nome_arquivo_saida, index=False, sep=';')
    print(f"\n-> Arquivo '{nome_arquivo_saida}' salvo com sucesso!")

    print("\n\n================================================")
    print("==   PROCESSO FINALIZADO COM SUCESSO!   ==")
    print("================================================")

except Exception as e:
    print("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print(f" OCORREU UM ERRO: {e}")
    print(" O processo foi interrompido. Verifique a mensagem de erro e os dados de diagnóstico acima.")
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    import traceback
    traceback.print_exc()

